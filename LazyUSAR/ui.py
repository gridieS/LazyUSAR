# Code generated by TkForge <https://github.com/axorax/tkforge>

import os
import sys
from time import sleep
import tkinter as tk
import keyboard
from .jumping_jacks import JumpingJackController


def load_asset(path):
    base = getattr(sys, "_MEIPASS", os.path.dirname(os.path.abspath(__file__)))
    assets = os.path.join(base, "assets")
    return os.path.join(assets, path)


UPPERCASE_JJ = "uppercase"
LOWERCASE_JJ = "lowercase"
GRAMMAR_JJ = "grammar"
HELL_JJ = "hell"

WINDOW_TITLE = "Jumping Jacks Macro"
APP_ICON = load_asset("app_icon.png")

MAX_JUMPING_JACKS = 1000
MIN_INTERVAL_TIME = 100

START_JJ_DEFAULT = 1
END_JJ_DEFAULT = 10
INTERVAL_DEFAULT_TIME = 300
END_CHARACTER_DEFAULT_CHAR = "!"
JJ_TYPE_DEFAULT = UPPERCASE_JJ


class JumpingJackUI:
    def __init__(
        self,
        exit_key: str,
        toggle_key: str,
    ):
        self.exit_key = exit_key
        self.toggle_key = toggle_key
        self.jumping_jack_controller = JumpingJackController(
            INTERVAL_DEFAULT_TIME,
            START_JJ_DEFAULT,
            END_JJ_DEFAULT,
            JJ_TYPE_DEFAULT,
            END_CHARACTER_DEFAULT_CHAR,
            False,
            self.toggle_controller,
        )
        self.running = False
        keyboard.hook(self.on_key_event)
        # make parse function for jumping_jack_controller, so it appears correctly on the ui
        # make buttons behave like checkboxes

    def start(self):
        self.window = tk.Tk()
        self.window.geometry("615x701")
        self.window.configure(bg="#d4d4d4")
        self.window.title(WINDOW_TITLE)
        self.window.iconphoto(True, tk.PhotoImage(file=APP_ICON))

        checked_image = tk.PhotoImage(file=load_asset("checked.png"))
        unchecked_image = tk.PhotoImage(file=load_asset("unchecked.png"))

        class Checkbox(tk.Checkbutton):
            def __init__(self, callback, checked=False, args=[]):
                self.state = tk.IntVar()
                super().__init__(
                    image=unchecked_image,
                    selectimage=checked_image,
                    indicatoron=False,
                    borderwidth=0,
                    command=self.on_press,
                    cursor="hand2",
                    variable=self.state,
                )
                self.args = args
                self.callback = callback
                if checked:
                    self.toggle()

            def toggle_callback(self):
                self.toggle()
                self.callback(self.state.get(), *self.args)

            def set(self, value: bool, trigger_callback=False):
                if self.state.get() != value:
                    if trigger_callback:
                        self.toggle_callback()
                    else:
                        self.toggle()

            def on_press(self):
                self.toggle()
                self.toggle_callback()

        canvas = tk.Canvas(
            self.window,
            bg="#d4d4d4",
            width=615,
            height=701,
            bd=0,
            highlightthickness=0,
            relief="ridge",
        )

        canvas.place(x=0, y=0)

        def start_entry_changed(event: tk.Event):
            self.update_preview()

        self.start_entry = tk.Entry(
            bg="#d9d9d9",
            borderwidth=2.25,
            justify="center",
            relief="solid",
            highlightbackground="black",
            font="Inter 14",
        )
        self.start_entry.place(x=77, y=156, width=206, height=33)
        self.start_entry.bind("<Return>", start_entry_changed)
        self.start_entry.bind("<FocusOut>", start_entry_changed)

        canvas.create_text(
            158, 129, anchor="nw", text="Start", fill="#000000", font=("Inter", 18 * -1)
        )
        canvas.create_text(
            115,
            201,
            anchor="nw",
            text="Jumping Jacks",
            fill="#000000",
            font=("Inter", 18 * -1),
        )

        def end_entry_changed(event: tk.Event):
            self.update_preview()

        self.end_entry = tk.Entry(
            bg="#d9d9d9",
            borderwidth=2.25,
            justify="center",
            font="Inter 14",
            relief="solid",
            highlightbackground="black",
        )

        self.end_entry.place(x=339, y=156, width=206, height=33)
        self.end_entry.bind("<Return>", end_entry_changed)
        self.end_entry.bind("<FocusOut>", end_entry_changed)

        canvas.create_text(
            426, 129, anchor="nw", text="End", fill="#000000", font=("Inter", 18 * -1)
        )
        canvas.create_text(
            378,
            201,
            anchor="nw",
            text="Jumping Jacks",
            fill="#000000",
            font=("Inter", 18 * -1),
        )

        # End character entry
        def end_character_entry_changed(event: tk.Event):
            self.update_preview()

        self.end_character_entry = tk.Entry(
            bg="#d9d9d9",
            borderwidth=2.25,
            justify="center",
            relief="solid",
            highlightbackground="black",
            font="Inter 14",
        )
        self.end_character_entry.place(x=341, y=270, width=203, height=33)
        self.end_character_entry.bind("<Return>", end_character_entry_changed)
        self.end_character_entry.bind("<FocusOut>", end_character_entry_changed)

        canvas.create_text(
            354,
            241,
            anchor="nw",
            text="Appended character",
            fill="#000000",
            font=("Inter", 18 * -1),
        )

        def hyphened_pressed(value: bool):
            self.update_preview()

        self.hyphened_checkbox = Checkbox(hyphened_pressed)
        self.hyphened_checkbox.place(x=289, y=351, width=36, height=36)

        canvas.create_text(
            263,
            322,
            anchor="nw",
            text="Hyphened",
            fill="#000000",
            font=("Inter", 18 * -1),
        )

        def interval_entry_changed(event: tk.Event):
            self.update_preview()

        # Interval rectangle
        self.interval_entry = tk.Entry(
            bg="#d9d9d9",
            borderwidth=2.25,
            justify="center",
            relief="solid",
            highlightbackground="black",
            font="Inter 14",
        )
        self.interval_entry.place(x=79, y=270, width=203, height=33)
        self.interval_entry.bind("<Return>", interval_entry_changed)
        self.interval_entry.bind("<FocusOut>", interval_entry_changed)

        canvas.create_text(
            147,
            241,
            anchor="nw",
            text="Interval",
            fill="#000000",
            font=("Inter", 18 * -1),
        )
        canvas.create_text(
            127,
            313,
            anchor="nw",
            text="Milliseconds",
            fill="#000000",
            font=("Inter", 18 * -1),
        )

        def jj_type_checkbox(value: bool, type: str):
            self.keep_only_type(type)

        self.uppercase_checkbox = Checkbox(jj_type_checkbox, args=[UPPERCASE_JJ])
        self.uppercase_checkbox.place(x=104, y=503, width=36, height=36)

        self.lowercase_checkbox = Checkbox(jj_type_checkbox, args=[LOWERCASE_JJ])
        self.lowercase_checkbox.place(x=234, y=503, width=36, height=36)

        self.grammar_checkbox = Checkbox(jj_type_checkbox, args=[GRAMMAR_JJ])
        self.grammar_checkbox.place(x=364, y=503, width=36, height=36)

        self.hell_checkbox = Checkbox(jj_type_checkbox, args=[HELL_JJ])
        self.hell_checkbox.place(x=491, y=503, width=36, height=36)

        # JJ types texts
        canvas.create_text(
            72,
            462,
            anchor="nw",
            text="UPPERCASE",
            fill="#000000",
            font=("Inter", 18 * -1),
        )
        canvas.create_text(
            206,
            462,
            anchor="nw",
            text="lowercase",
            fill="#000000",
            font=("Inter", 18 * -1),
        )
        canvas.create_text(
            339,
            462,
            anchor="nw",
            text="Grammar",
            fill="#000000",
            font=("Inter", 18 * -1),
        )
        canvas.create_text(
            480,
            462,
            anchor="nw",
            text="H E L L",
            fill="#000000",
            font=("Inter", 18 * -1),
        )

        # JJ types text
        canvas.create_text(
            286, 413, anchor="nw", text="Type", fill="#000000", font=("Inter", 18 * -1)
        )

        # JJ types lines
        canvas.create_line(52, 568, 563, 568, fill="#000000", width=0.75)
        canvas.create_line(52, 445, 563, 445, fill="#000000", width=0.75)
        canvas.create_line(52, 445, 52, 568, fill="#000000", width=0.75)
        canvas.create_line(563, 446, 563, 569, fill="#000000", width=0.75)

        canvas.create_text(
            274,
            83,
            anchor="nw",
            text="Options",
            fill="#000000",
            font=("Inter", 18 * -1),
        )

        # Options lines
        canvas.create_line(52, 402, 565, 402, fill="#000000", width=0.75)
        canvas.create_line(52, 111, 563, 111, fill="#000000", width=0.75)
        canvas.create_line(52, 113, 52, 403, fill="#000000", width=0.75)
        canvas.create_line(563, 112, 564, 402, fill="#000000", width=0.75)

        # Preview rectangle
        canvas.create_text(
            273,
            593,
            anchor="nw",
            text="Preview",
            fill="#000000",
            font=("Inter", 18 * -1),
        )
        self.preview_text = tk.Label(
            text="One!",
            bg="#d9d9d9",
            relief="solid",
            borderwidth="2.25",
            justify="center",
            font="Inter 14",
        )
        self.preview_text.place(x=54, y=622, width=508, height=37)

        def toggle_button_pressed(event):
            self.toggle_controller()

        canvas.create_rectangle(
            138, 30, 478, 67, fill="#d9d9d9", outline="#9f9f9f", width="2.25"
        )
        self.toggle_button_text = tk.Label(
            text=f"Press {self.toggle_key.upper()} to start",
            bg="#d9d9d9",
            borderwidth=0,
            justify="center",
            font="Inter 14",
        )
        self.toggle_button_text.place(x=140, y=32, width=336, height=33)
        self.toggle_button_text.bind("<Button-1>", toggle_button_pressed)

        self.default_remake()

        self.window.resizable(False, False)
        self.window.mainloop()

    def exit(self):
        self.window.destroy()

    def toggle_controller(self):
        if not self.check_parameters():
            return
        self.running = self.jumping_jack_controller.toggle()
        if self.running:
            toggle_text = f"Press {self.toggle_key.upper()} to stop"
            self.jumping_jack_controller.start()
        else:
            toggle_text = f"Press {self.toggle_key.upper()} to start"
            self.jumping_jack_controller.stop()

        self.toggle_button_text.config(text=toggle_text)

    def on_key_event(self, key: keyboard.KeyboardEvent):
        if key.event_type != "down":
            return
        if key.name == self.exit_key:
            self.exit()
        if key.name == self.toggle_key:
            self.toggle_controller()

    def get_active_jj_type(self) -> str:
        if self.uppercase_checkbox.state.get():
            return UPPERCASE_JJ
        if self.lowercase_checkbox.state.get():
            return LOWERCASE_JJ
        if self.grammar_checkbox.state.get():
            return GRAMMAR_JJ
        if self.hell_checkbox.state.get():
            return HELL_JJ

    def update_controller(self):
        parameters_changed = (
            int(self.interval_entry.get()) != self.jumping_jack_controller.interval
            or int(self.start_entry.get()) != self.jumping_jack_controller.starting_jj
            or int(self.end_entry.get()) != self.jumping_jack_controller.ending_jj
            or self.get_active_jj_type()
            != self.jumping_jack_controller.get_jj_type().name.lower()
            or self.end_character_entry.get()
            != self.jumping_jack_controller.end_of_word
            or self.hyphened_checkbox.state.get()
            != int(self.jumping_jack_controller.hyphened)
        )
        if parameters_changed and self.running:
            self.toggle_controller()

            self.jumping_jack_controller.remake(
                int(self.interval_entry.get()),
                int(self.start_entry.get()),
                int(self.end_entry.get()),
                self.get_active_jj_type(),
                self.end_character_entry.get(),
                self.hyphened_checkbox.state.get(),
                self.toggle_controller,
            )

    def check_parameters(self) -> bool:
        if (
            self.interval_entry.get() == ""
            or self.start_entry.get() == ""
            or self.end_entry.get() == ""
        ):
            return False
        elif (
            not self.interval_entry.get().isnumeric()
            or not self.start_entry.get().isnumeric()
            or not self.end_entry.get().isnumeric()
        ):
            return False
        elif int(self.interval_entry.get()) < MIN_INTERVAL_TIME:
            return False
        elif int(self.end_entry.get()) > MAX_JUMPING_JACKS:
            return False

        return True

    def keep_only_type(self, current_type: str):
        if current_type != UPPERCASE_JJ:
            self.uppercase_checkbox.set(False)
        if current_type != LOWERCASE_JJ:
            self.lowercase_checkbox.set(False)
        if current_type != GRAMMAR_JJ:
            self.grammar_checkbox.set(False)
        if current_type != HELL_JJ:
            self.hell_checkbox.set(False)

        if current_type == UPPERCASE_JJ:
            self.uppercase_checkbox.set(True)
        if current_type == LOWERCASE_JJ:
            self.lowercase_checkbox.set(True)
        if current_type == GRAMMAR_JJ:
            self.grammar_checkbox.set(True)
        if current_type == HELL_JJ:
            self.hell_checkbox.set(True)

        self.update_preview()

    def default_remake(self):
        self.end_character_entry.delete(0, tk.END)
        self.end_character_entry.insert(tk.END, END_CHARACTER_DEFAULT_CHAR)
        self.interval_entry.delete(0, tk.END)
        self.interval_entry.insert(tk.END, str(INTERVAL_DEFAULT_TIME))
        self.uppercase_checkbox.toggle_callback()
        self.hyphened_checkbox.set(False)
        self.start_entry.delete(0, tk.END)
        self.start_entry.insert(tk.END, START_JJ_DEFAULT)
        self.end_entry.delete(0, tk.END)
        self.end_entry.insert(tk.END, END_JJ_DEFAULT)
        self.keep_only_type(JJ_TYPE_DEFAULT)

        self.update_preview()

    def update_preview(self):
        if self.get_active_jj_type() == UPPERCASE_JJ:
            preview_text = "TWENTY ONE" + self.end_character_entry.get()
        elif self.get_active_jj_type() == LOWERCASE_JJ:
            preview_text = "twenty one" + self.end_character_entry.get()
        elif self.get_active_jj_type() == GRAMMAR_JJ:
            preview_text = "Twenty one" + self.end_character_entry.get()

        if self.get_active_jj_type() == HELL_JJ:
            preview_text = "T W E N T Y O N E" + self.end_character_entry.get()
        else:
            if self.hyphened_checkbox.state.get():
                preview_text = preview_text.replace(" ", "-")

        self.preview_text.config(text=preview_text)

        passed_checks = self.check_parameters()
        if passed_checks:
            self.update_controller()
